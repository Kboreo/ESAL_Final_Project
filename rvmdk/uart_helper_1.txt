; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\rvmdk\uart_helper_1.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\uart_helper_1.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\.. -I.\driverlib -I.\src -I.\inc -I.\RTE\_project -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\TM4C_DFP\1.1.0\Device\Include\TM4C123 -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DTM4C123GH6PM -Drvmdk -DPART_TM4C123GH6PM -DTARGET_IS_TM4C123_RB1 --omf_browse=.\rvmdk\uart_helper_1.crf src\Uart_helper.c]
                          THUMB

                          AREA ||i.UART_InChar||, CODE, READONLY, ALIGN=2

                  UART_InChar PROC
;;;56     // Output: ASCII code for key typed
;;;57     char UART_InChar()
000000  bf00              NOP      
                  |L1.2|
;;;58     {
;;;59     	while((UART0_FR_R&UART_FR_RXFE) !=0){};
000002  4805              LDR      r0,|L1.24|
000004  6980              LDR      r0,[r0,#0x18]
000006  f0000010          AND      r0,r0,#0x10
00000a  2800              CMP      r0,#0
00000c  d1f9              BNE      |L1.2|
;;;60     	return ((char)(UART0_DR_R&0xFF)); //returns the character from the port
00000e  4802              LDR      r0,|L1.24|
000010  6800              LDR      r0,[r0,#0]
000012  b2c0              UXTB     r0,r0
;;;61     }
000014  4770              BX       lr
;;;62     
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x4000c000

                          AREA ||i.UART_OutChar||, CODE, READONLY, ALIGN=2

                  UART_OutChar PROC
;;;36     // Output: none
;;;37     void UART_OutChar(char data){
000000  bf00              NOP      
                  |L2.2|
;;;38       while((UART0_FR_R&UART_FR_TXFF) != 0);
000002  4904              LDR      r1,|L2.20|
000004  6989              LDR      r1,[r1,#0x18]
000006  f0010120          AND      r1,r1,#0x20
00000a  2900              CMP      r1,#0
00000c  d1f9              BNE      |L2.2|
;;;39       UART0_DR_R = data;
00000e  4901              LDR      r1,|L2.20|
000010  6008              STR      r0,[r1,#0]
;;;40     }
000012  4770              BX       lr
;;;41     
                          ENDP

                  |L2.20|
                          DCD      0x4000c000

                          AREA ||i.UartSetup||, CODE, READONLY, ALIGN=2

                  UartSetup PROC
;;;10     // Output: none
;;;11     void UartSetup()
000000  b510              PUSH     {r4,lr}
;;;12     {
;;;13     		SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);		// Enable the UART0 module.
000002  4815              LDR      r0,|L3.88|
000004  f7fffffe          BL       SysCtlPeripheralEnable
;;;14     		while(!SysCtlPeripheralReady(SYSCTL_PERIPH_UART0))
000008  bf00              NOP      
                  |L3.10|
00000a  4813              LDR      r0,|L3.88|
00000c  f7fffffe          BL       SysCtlPeripheralReady
000010  2800              CMP      r0,#0
000012  d0fa              BEQ      |L3.10|
;;;15     		{
;;;16     			// Wait for the UART0 module to be ready.
;;;17     		}
;;;18     		
;;;19     		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); 		// activate port A
000014  4811              LDR      r0,|L3.92|
000016  f7fffffe          BL       SysCtlPeripheralEnable
;;;20     		GPIOPinConfigure(GPIO_PA0_U0RX); 								//Pin 0 is configured as receive
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       GPIOPinConfigure
;;;21     		GPIOPinConfigure(GPIO_PA1_U0TX); 								//Pin 1 is configured as transmit
000020  f2404001          MOV      r0,#0x401
000024  f7fffffe          BL       GPIOPinConfigure
;;;22     		
;;;23     		// enable alt funct on PA1-0 and enable digital I/O on PA1-0
;;;24     		GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_1|GPIO_PIN_1);
000028  2102              MOVS     r1,#2
00002a  f04f2040          MOV      r0,#0x40004000
00002e  f7fffffe          BL       GPIOPinTypeUART
;;;25     		GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0|GPIO_PIN_1);
000032  2103              MOVS     r1,#3
000034  f04f2040          MOV      r0,#0x40004000
000038  f7fffffe          BL       GPIOPinTypeUART
;;;26     		
;;;27     		// Initialize the UART. Set the baud rate, number of data bits, turn off
;;;28     		// parity, number of stop bits, and stick mode. The UART is enabled by the
;;;29     		SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);   
00003c  4808              LDR      r0,|L3.96|
00003e  f7fffffe          BL       SysCtlClockSet
;;;30     		UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), 38400,(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |UART_CONFIG_PAR_NONE));
000042  f7fffffe          BL       SysCtlClockGet
000046  4604              MOV      r4,r0
000048  2360              MOVS     r3,#0x60
00004a  f44f4216          MOV      r2,#0x9600
00004e  4621              MOV      r1,r4
000050  4804              LDR      r0,|L3.100|
000052  f7fffffe          BL       UARTConfigSetExpClk
;;;31     }
000056  bd10              POP      {r4,pc}
;;;32     
                          ENDP

                  |L3.88|
                          DCD      0xf0001800
                  |L3.92|
                          DCD      0xf0000800
                  |L3.96|
                          DCD      0x07803d40
                  |L3.100|
                          DCD      0x4000c000

                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;68     // Function called when file error occurs.
;;;69     int ferror(FILE *f){
000000  4601              MOV      r1,r0
;;;70       /* Your implementation of ferror */
;;;71       return 1;
000002  2001              MOVS     r0,#1
;;;72     }
000004  4770              BX       lr
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;63     // Get a character from UART.
;;;64     int fgetc(FILE *f){
000000  b500              PUSH     {lr}
000002  4601              MOV      r1,r0
;;;65       return UART_InChar();
000004  f7fffffe          BL       UART_InChar
;;;66     }
000008  bd00              POP      {pc}
;;;67     
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;42     // Print a character to UART.
;;;43     int fputc(int ch, FILE *f){
000000  b500              PUSH     {lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;44       if((ch == 10) || (ch == 13) || (ch == 27)){
000006  2a0a              CMP      r2,#0xa
000008  d003              BEQ      |L6.18|
00000a  2a0d              CMP      r2,#0xd
00000c  d001              BEQ      |L6.18|
00000e  2a1b              CMP      r2,#0x1b
000010  d107              BNE      |L6.34|
                  |L6.18|
;;;45         UART_OutChar(13);
000012  200d              MOVS     r0,#0xd
000014  f7fffffe          BL       UART_OutChar
;;;46         UART_OutChar(10);
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       UART_OutChar
;;;47         return 1;
00001e  2001              MOVS     r0,#1
                  |L6.32|
;;;48       }
;;;49       UART_OutChar(ch);
;;;50       return 1;
;;;51     }
000020  bd00              POP      {pc}
                  |L6.34|
000022  b2d0              UXTB     r0,r2                 ;49
000024  f7fffffe          BL       UART_OutChar
000028  2001              MOVS     r0,#1                 ;50
00002a  e7f9              B        |L6.32|
;;;52     
                          ENDP

