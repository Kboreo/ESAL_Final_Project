; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\rvmdk\mygpio.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\mygpio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\.. -I.\driverlib -I.\src -I.\inc -I.\RTE\_project -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\TM4C_DFP\1.1.0\Device\Include\TM4C123 -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DTM4C123GH6PM -Drvmdk -DPART_TM4C123GH6PM -DTARGET_IS_TM4C123_RB1 --omf_browse=.\rvmdk\mygpio.crf myGPIO.c]
                          THUMB

                          AREA ||i.PortF_Init||, CODE, READONLY, ALIGN=2

                  PortF_Init PROC
;;;63     // PF3,PF2,PF1 are outputs to the LED
;;;64     void PortF_Init(void)
000000  b508              PUSH     {r3,lr}
;;;65     	{ 
;;;66       volatile unsigned long delay;
;;;67       SYSCTL_RCGC2_R |= 0x00000020;     // 1) F clock
000002  4812              LDR      r0,|L1.76|
000004  6800              LDR      r0,[r0,#0]
000006  f0400020          ORR      r0,r0,#0x20
00000a  4911              LDR      r1,|L1.80|
00000c  f8c10108          STR      r0,[r1,#0x108]
;;;68       delay = SYSCTL_RCGC2_R;           // reading register adds a delay   
000010  480e              LDR      r0,|L1.76|
000012  6800              LDR      r0,[r0,#0]
000014  9000              STR      r0,[sp,#0]
;;;69       GPIO_PORTF_LOCK_R = 0x4C4F434B;   // 2) unlock PortF PF0  
000016  480f              LDR      r0,|L1.84|
000018  490f              LDR      r1,|L1.88|
00001a  6008              STR      r0,[r1,#0]
;;;70       GPIO_PORTF_CR_R = 0x1F;           // allow changes to PF4-0       
00001c  201f              MOVS     r0,#0x1f
00001e  1d09              ADDS     r1,r1,#4
000020  6008              STR      r0,[r1,#0]
;;;71       GPIO_PORTF_AMSEL_R = 0x00;        // 3) disable analog function
000022  2000              MOVS     r0,#0
000024  1d09              ADDS     r1,r1,#4
000026  6008              STR      r0,[r1,#0]
;;;72       GPIO_PORTF_PCTL_R = 0x00000000;   // 4) GPIO clear bit PCTL  
000028  1d09              ADDS     r1,r1,#4
00002a  6008              STR      r0,[r1,#0]
;;;73       GPIO_PORTF_DIR_R = 0x0E;          // 5) PF4,PF0 input, PF3,PF2,PF1 output   
00002c  200e              MOVS     r0,#0xe
00002e  490b              LDR      r1,|L1.92|
000030  6008              STR      r0,[r1,#0]
;;;74       GPIO_PORTF_AFSEL_R = 0x00;        // 6) no alternate function
000032  2000              MOVS     r0,#0
000034  4909              LDR      r1,|L1.92|
000036  3120              ADDS     r1,r1,#0x20
000038  6008              STR      r0,[r1,#0]
;;;75       GPIO_PORTF_PUR_R = 0x11;          // enable pullup resistors on PF4,PF0       
00003a  2011              MOVS     r0,#0x11
00003c  4906              LDR      r1,|L1.88|
00003e  3910              SUBS     r1,r1,#0x10
000040  6008              STR      r0,[r1,#0]
;;;76       GPIO_PORTF_DEN_R = 0x1F;          // 7) enable digital pins PF4-PF0        
000042  201f              MOVS     r0,#0x1f
000044  4904              LDR      r1,|L1.88|
000046  1f09              SUBS     r1,r1,#4
000048  6008              STR      r0,[r1,#0]
;;;77     }
00004a  bd08              POP      {r3,pc}
;;;78     
                          ENDP

                  |L1.76|
                          DCD      0x400fe108
                  |L1.80|
                          DCD      0x400fe000
                  |L1.84|
                          DCD      0x4c4f434b
                  |L1.88|
                          DCD      0x40025520
                  |L1.92|
                          DCD      0x40025400

                          AREA ||i.pinReadAndWrite||, CODE, READONLY, ALIGN=2

                  pinReadAndWrite PROC
;;;78     
;;;79     void pinReadAndWrite(uint32_t ui32Loop,uint8_t temp)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;80     {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;81     	int i = 1;
000008  2701              MOVS     r7,#1
;;;82     	printf("Press SW1 to turn on Blue LED\nPress SW2 to turn on Red LED\n"); 
00000a  a024              ADR      r0,|L2.156|
00000c  f7fffffe          BL       __2printf
;;;83     	printf("Press both SW1 and SW2 to exit GPIO\n\n");
000010  a031              ADR      r0,|L2.216|
000012  f7fffffe          BL       __2printf
;;;84     	
;;;85     	
;;;86     	while (i == 1)
000016  e03c              B        |L2.146|
                  |L2.24|
;;;87     	{
;;;88     		int x;  //Int that contains the output of the button SW2
;;;89     		int y;  //Int that contains the output of the button SW1
;;;90     
;;;91     		x = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_0); // set x equal to the output of button SW2 
000018  2101              MOVS     r1,#1
00001a  4839              LDR      r0,|L2.256|
00001c  f7fffffe          BL       GPIOPinRead
000020  4605              MOV      r5,r0
;;;92     		y = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4); // set y equal to the output of button SW1		
000022  2110              MOVS     r1,#0x10
000024  4836              LDR      r0,|L2.256|
000026  f7fffffe          BL       GPIOPinRead
00002a  4606              MOV      r6,r0
;;;93     			
;;;94     			if (y == 0) //if loop that checks if SW1 is pressed, if it is pressed, blue LED will light.
00002c  b9b6              CBNZ     r6,|L2.92|
;;;95     			{
;;;96     				GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, 0xF);  // Turn on blue LED
00002e  220f              MOVS     r2,#0xf
000030  2104              MOVS     r1,#4
000032  4833              LDR      r0,|L2.256|
000034  f7fffffe          BL       GPIOPinWrite
;;;97     				
;;;98             //Delay for a bit.
;;;99             for(ui32Loop = 0; ui32Loop < 200000; ui32Loop++)
000038  2400              MOVS     r4,#0
00003a  e000              B        |L2.62|
                  |L2.60|
00003c  1c64              ADDS     r4,r4,#1
                  |L2.62|
00003e  4831              LDR      r0,|L2.260|
000040  4284              CMP      r4,r0
000042  d3fb              BCC      |L2.60|
;;;100            {
;;;101            }
;;;102    
;;;103            //Turn off the LED.
;;;104            GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, 0x0);
000044  2200              MOVS     r2,#0
000046  2104              MOVS     r1,#4
000048  482d              LDR      r0,|L2.256|
00004a  f7fffffe          BL       GPIOPinWrite
;;;105    
;;;106            //Delay for a bit.
;;;107            for(ui32Loop = 0; ui32Loop < 200000; ui32Loop++)
00004e  2400              MOVS     r4,#0
000050  e000              B        |L2.84|
                  |L2.82|
000052  1c64              ADDS     r4,r4,#1
                  |L2.84|
000054  482b              LDR      r0,|L2.260|
000056  4284              CMP      r4,r0
000058  d3fb              BCC      |L2.82|
00005a  e016              B        |L2.138|
                  |L2.92|
;;;108            {
;;;109            }			
;;;110    			}
;;;111    			else if (x == 0) //if loop that checks if SW2 is pressed, if  pressed, red LED will light.
00005c  b9ad              CBNZ     r5,|L2.138|
;;;112    			{
;;;113    				GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0xF);  // Turn on blue LED
00005e  220f              MOVS     r2,#0xf
000060  2102              MOVS     r1,#2
000062  4827              LDR      r0,|L2.256|
000064  f7fffffe          BL       GPIOPinWrite
;;;114    				
;;;115            //Delay for a bit.
;;;116            for(ui32Loop = 0; ui32Loop < 200000; ui32Loop++)
000068  2400              MOVS     r4,#0
00006a  e000              B        |L2.110|
                  |L2.108|
00006c  1c64              ADDS     r4,r4,#1
                  |L2.110|
00006e  4825              LDR      r0,|L2.260|
000070  4284              CMP      r4,r0
000072  d3fb              BCC      |L2.108|
;;;117            {
;;;118            }
;;;119    
;;;120            //Turn off the LED.
;;;121            GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0x0);
000074  2200              MOVS     r2,#0
000076  2102              MOVS     r1,#2
000078  4821              LDR      r0,|L2.256|
00007a  f7fffffe          BL       GPIOPinWrite
;;;122    
;;;123            //Delay for a bit.
;;;124            for(ui32Loop = 0; ui32Loop < 200000; ui32Loop++)
00007e  2400              MOVS     r4,#0
000080  e000              B        |L2.132|
                  |L2.130|
000082  1c64              ADDS     r4,r4,#1
                  |L2.132|
000084  481f              LDR      r0,|L2.260|
000086  4284              CMP      r4,r0
000088  d3fb              BCC      |L2.130|
                  |L2.138|
;;;125            {
;;;126            }				
;;;127    			}
;;;128    			//will exit GPIO when both SW1 and SW2 are pressed
;;;129    			if ( x == 0)
00008a  b90d              CBNZ     r5,|L2.144|
;;;130    		 {
;;;131    			 if (y == 0)
00008c  b906              CBNZ     r6,|L2.144|
;;;132    			 {
;;;133    					i = 0;
00008e  2700              MOVS     r7,#0
                  |L2.144|
;;;134    			 }
;;;135    		 }				
;;;136        }		
000090  bf00              NOP      
                  |L2.146|
000092  2f01              CMP      r7,#1                 ;86
000094  d0c0              BEQ      |L2.24|
;;;137    }
000096  e8bd81f0          POP      {r4-r8,pc}
;;;138    	
                          ENDP

00009a  0000              DCW      0x0000
                  |L2.156|
00009c  50726573          DCB      "Press SW1 to turn on Blue LED\nPress SW2 to turn on Red"
0000a0  73205357
0000a4  3120746f
0000a8  20747572
0000ac  6e206f6e
0000b0  20426c75
0000b4  65204c45
0000b8  440a5072
0000bc  65737320
0000c0  53573220
0000c4  746f2074
0000c8  75726e20
0000cc  6f6e2052
0000d0  6564    
0000d2  204c4544          DCB      " LED\n",0
0000d6  0a00    
                  |L2.216|
0000d8  50726573          DCB      "Press both SW1 and SW2 to exit GPIO\n\n",0
0000dc  7320626f
0000e0  74682053
0000e4  57312061
0000e8  6e642053
0000ec  57322074
0000f0  6f206578
0000f4  69742047
0000f8  50494f0a
0000fc  0a00    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L2.256|
                          DCD      0x40025000
                  |L2.260|
                          DCD      0x00030d40

                          AREA ||i.setup_IO||, CODE, READONLY, ALIGN=2

                  setup_IO PROC
;;;36     
;;;37     void setup_IO()
000000  b510              PUSH     {r4,lr}
;;;38     {
;;;39     	//Enable the GPIO port that is used for the on-board LED.
;;;40     	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
000002  4811              LDR      r0,|L3.72|
000004  f7fffffe          BL       SysCtlPeripheralEnable
;;;41     	//Enable the GPIO pin for the LED (PF3).  Set the direction as output, and
;;;42       //enable the GPIO pin for digital function.
;;;43       GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3|GPIO_PIN_1); // set pin 3,2, and 1 as output
000008  210a              MOVS     r1,#0xa
00000a  4810              LDR      r0,|L3.76|
00000c  f7fffffe          BL       GPIOPinTypeGPIOOutput
;;;44     	GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4|GPIO_PIN_0); // set pin 4 and 0 as input
000010  2111              MOVS     r1,#0x11
000012  480e              LDR      r0,|L3.76|
000014  f7fffffe          BL       GPIOPinTypeGPIOInput
;;;45     	//these two switches need an internal pull up on pins
;;;46     	GPIOPadConfigSet(GPIO_PORTF_BASE,GPIO_PIN_0|GPIO_PIN_4,GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);//set internal pullup R for pin 0 and 4
000018  230a              MOVS     r3,#0xa
00001a  2201              MOVS     r2,#1
00001c  2111              MOVS     r1,#0x11
00001e  480b              LDR      r0,|L3.76|
000020  f7fffffe          BL       GPIOPadConfigSet
;;;47       while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOF))
000024  bf00              NOP      
                  |L3.38|
000026  4808              LDR      r0,|L3.72|
000028  f7fffffe          BL       SysCtlPeripheralReady
00002c  2800              CMP      r0,#0
00002e  d0fa              BEQ      |L3.38|
;;;48       {
;;;49         
;;;50     	}	
;;;51     	//Need to Unlock PF4
;;;52     	HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
000030  4807              LDR      r0,|L3.80|
000032  4908              LDR      r1,|L3.84|
000034  6008              STR      r0,[r1,#0]
;;;53     	HWREG(GPIO_PORTF_BASE + GPIO_O_CR) = 0xFF;
000036  20ff              MOVS     r0,#0xff
000038  1d09              ADDS     r1,r1,#4
00003a  6008              STR      r0,[r1,#0]
;;;54     	HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = 0;
00003c  2000              MOVS     r0,#0
00003e  1f09              SUBS     r1,r1,#4
000040  6008              STR      r0,[r1,#0]
;;;55     	//3. Subroutines Section
;;;56        
;;;57       PortF_Init();		//Call initialization of port PF0-PF4    
000042  f7fffffe          BL       PortF_Init
;;;58     
;;;59     }
000046  bd10              POP      {r4,pc}
;;;60     
                          ENDP

                  |L3.72|
                          DCD      0xf0000805
                  |L3.76|
                          DCD      0x40025000
                  |L3.80|
                          DCD      0x4c4f434b
                  |L3.84|
                          DCD      0x40025520

                          AREA ||.data||, DATA, ALIGN=2

                  ||SW1||
                          DCD      0x00000000
                  ||SW2||
                          DCD      0x00000000
